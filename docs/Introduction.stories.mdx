import { Meta } from '@storybook/addon-docs/blocks'

<Meta title="Introduction" />

# Flatiron School Design System

The Flatiron School Design systems allows the company to manage design at scale. A design system is a collection of reusable
components, guided by clear standards, that can be assembled together to build any number of applications. The implementation
of this design system will allow for a consistent look and feel across any application within Flatiron School.

The purpose of this document is to provide guidelines on how to develop components for Flatiron school.

## Assumptions

This process overview covers defining requirements, writing code, and deploying software and assumes that all design work for a particular iteration of a component has already been completed and is in the design system. It does not attempt to define the design process. This process also assumes that all components will be built in an iterative fashion and will be under constant development.

## Working Definitions

In order to facilitate a shared language around how work is completed, it’s helpful to have definitions for the gating phases of the process. At a high level, the critical stages of the process are:

- Team Review
- Design Ready
- Ready for Development
- Development Complete
- Deployment Complete
- Socialize New Components

### Team Review

- Small brain trust, intentional submissions and decision road map.
- Allows stakeholders ie. engineering, product, management to review components before decisions are made.

### Design Ready

A component is design ready when the component’s iteration has been built out visually. This means the following criteria has been met:

- Success states defined
  - Error states defined
  - Loading state defined
  - Viewport states defined
- Any special accessibility requirements defined

This criteria is defined by the design team and reviewed by the engineering team before development can begin.

### Ready for Development

The team can develop a component when the designs are ready and a ticket or tickets have been created to complete the work. For a ticket to be ready for development, it must meet the following criteria:

- Design assets are attached or linked in ticket
- User story is defined
- Success behavior is captured (if applicable)
- Error behavior is captured (if applicable)
- Loading behavior is captured (if applicable)
- Any other applicable component state are captured
- Any accessibility requirements are captured

### Development Complete

A component iteration is considered complete when the following is true:

- Code is complete
- Storybook component implementation is complete
- Applicable documentation is written
- Tests (including accessibility tests) are written

### Deployment Complete

A component library deployment is considered complete when the following is true: a new version of the component library is published and available for use.{' '}

### Socialize New Version

It’s important to communicate that a new version of the component library has been deployed. Socializing a new version means the following:

- All applicable consumers are notified through some means.
- Links to the newly deployed version of the component library are included.
- Links to the updated documentation of the component library are included.

## Addressing Defects

It can be difficult to know if a defect exists in a component after it’s been published. Often, bugs in the parent application are mistaken for defects in the components and vice versa. In addition, because of the iterative nature of a component library, a lack of certain behavior in a component may be seen as a defect. To address this issue, any defect tickets assigned to the team responsible for the component library must include the following:

At least one of these:

- Explicit steps to navigate to the area of application where the component has been implements.
- A video of the behavior of the component in question.
- A screenshot of the behavior of the component in question (may not always been sufficient).

And all of these:

- Explicit steps to reproduce
- Any relevant console information
- Any relevant prop data
- Any extra content that would be helpful
- Version of the component library being used
- Expected behavior
- Actual behavior

## Open Source Contract

The component library is a shared resource at Flatiron School. Many teams and engineers will use it and all can contribute to it. This can include new components, updating existing components, and fixing bugs. It’s an open source project within the company.

### Contribution Guidelines

As with any open source project there are guidelines that must be adhered to for a contribution to be accepted into the codebase. These include but are not limited to:

- Coding styles and standards
  - Naming conventions
  - Code format
- Testing
- Style definitions and their application
- Accessibility standards

### Coordination

In order to maintain good coordination and planning between teams the component library will have a member of product. As a contributor to the component library, you must work with the product team prior to doing any development. Contact the product in the following circumstances:

- You don’t see a component you need in the component library and want to create it
- You don’t see the behavior in a component that you need and you want to add it
- You have an idea for a new component that would be useful in your application
- There’s a bug in an existing component and you want to fix it
- There’s an issue with the styles in a component and you want to fix it

### Governance / Code Review

The team responsible for the component library will decide what is accepted into the codebase. All feedback and guidance from that team needs to be fulfilled before any contribution will be accepted.

## Working Agreement with Design

### Design System

A design system is a visual implementation of design concepts that promote a specific look and feel to the user. A design system does define components and their specifications but it does not implement them for use in applications. Does not necessarily require code to be written.

### Component Library

The purpose of a component library is to encapsulate a design system and dramatically increase developer velocity. It is a technical implementation of a design system and requires code to be written. It provides developers usable componentry based on the guidelines set forth in the design system. This means that all components defined in the design system will exist in the component library, in addition to any other useful componentry, types, or utilities that will help aid application development.

## Roles & Responsibilities

### Design

The design team owns the look, feel, specifications, and documentation of the design system. This includes but is not limited to:

- Typography
- Icons
- Color palette
- Component definitions
  - Use cases the component fulfills
  - How the component might change at different view ports
  - Validation states of a component
  - Error states of a component
  - Loading states of a component
  - ‘No data’ states of a component
- Documentation of design system
  - When to use a component
  - Why to use a component
  - Behavior of each component
  - Versioning of design system documentation
- Communication of new versions when available

### Engineering

The engineering team owns the implementation, technical design, testing, deployment, and documentation of the component library. This includes but is not limited to:

- Programming language(s)
- Libraries
- Component accessibility compliance
- Testing suites
- Test coverage
- Deployment strategy
- Documentation
  - Code documentation
  - Implementation documentation
- Communication of new versions when available

## Assets

Design assets will be delivered to the team via Figma. Design assets must call out, include, or link to the following in order to consider a design iteration ready:

- Colors used
- Typography used
- Icons used
- Call out other components used in design

## Collaboration

Designs sometimes have technical implications which should be considered before finalizing a new design. It’s good practice to review new designs with the engineering team when the design team feels a new design is gaining traction. This can be done in an async fashion with the technical lead in charge of the component library in most cases. Either team can call a meeting if they feel it’s worthwhile to meet to discuss in real-time.
